# C-language_Study
注意C语言中的 "" 和 ''

sizeof 是一个操作符 计算一个数或者类型所占用内存空间的大小, sizeof()单位是byte（字节）。

strlen() 计算数组字符串的长度。

scanf() 接收从键盘输入的值。

Sleep() 参数是毫秒，表示休眠停顿多久 

system() 是 windows系统函数,里面可以放一些dos命名

system("cls") 清空屏幕

gets() 读取一行的字符串，当读取到换行符时，或者到达文件末尾时，它会停止

### 练习：编写代码，演示多个字符从两端移动，向中间汇聚

~~~c
#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<windows.h>
int main() {
	//编写代码，演示多个字符从两端移动，向中间汇聚
	//welcome to bit...
	//#################
	char arr1[] = "welcome to bit!!!!!!";
	char arr2[] = "####################";
	int left = 0;
	int right = strlen(arr1) - 1;
	//条件是当它们当left还小于等于right的时候表示它们还没相交
	while (left<=right) {
		arr2[left] = arr1[left];
		left++;
		arr2[right] = arr1[right];
		right--;
		printf("%s\n", arr2);
		Sleep(1000); // 单位是毫秒，作用是停一秒 要引入头文件<windows.h>
		system("cls"); // 清空屏幕 
	}
	printf("%s\n", arr2);
	return 0;
}
~~~

### 练习：编写代码实现，模拟用户登录情景，并且只能登录三次。（只允许输入三次密码，如果密码正确则提示登录成功，如果三次均输入错误，退出程序）

~~~c
#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
int main() {
	//编写代码实现，模拟用户登录情景，并且只能登录三次。（只允许输入三次密码，如果密码正确则提示登录成功，如果三次均输入错误，退出程序）
	char password[] = "abcd";
	char target[20] = { 0 };
	int i = 0;
	for (i = 0; i < 3; i++) {
		printf("请输入密码:>\n");
		scanf("%s", target);
		if (strcmp(target, password) == 0) {
			printf("登录成功！\n");
			break;
		}
	}
	//printf("密码错误！");
	if (i == 3) {
		printf("三次密码错误！！退出程序\n");
	}
	return 0;
}
~~~

两个字符比较应该用strcmp函数来比较.

如果用两个字符比较它比的是字符的首字母内存地址

**strcmp()**函数接收两个参数，第一个是要比较的字符，第二个是被比较的字符。如果相等函数返回0，它内部比较的是每个字符的Ascll值。

### 练习：猜数字实现

//生成1-100的随机数
//1.有个菜单 两个选择 1开始游戏 0结束游戏
//如果选择0退出游戏 ，选择1 提示输入一个数，然后开始猜，猜大了就提示猜大了，小了提示猜小了，直到猜对了。
//猜对了不退出游戏，而是继续回到菜单选择

~~~c
#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
void menu() {
	printf("****************************\n");
	printf("********* 1.play ***********\n");
	printf("********* 0.exit ***********\n");
	printf("****************************\n");
}
void game() {
	//printf("请选中")
	int ret = rand() % 100 + 1;  //rand生成一个随机数 模100 + 1 生成0-100的随机数      rand之前调用下srand函数
	int  guess = 0;
	while (1)
	{
		printf("请猜数字\n");   //  90 > 80 
		scanf("%d", &guess);
		if (ret > guess) { 
			printf("猜小了\n");
		}
		else if (ret < guess) {
			printf("猜大了\n");
		}
		else {
			printf("猜对了\n");
			break;
		}
	}
}
int main() {
	//猜数字实现
	int input = 0;
	srand((unsigned int)time(NULL));  // 强制类型转换  （类型） 
	do{
		menu();
		printf("输入选项:>");
		scanf("%d", &input);
		switch (input) {
		case 1:
			game();
			break;
		case 0:
			printf("退出游戏\n");
			break;
		default:
			printf("请输入合法的数字\n");
			break;
		}
	} while (input);
	return 0;
}
~~~

# 关于编程

写代码吃力正常吗？

太正常了

1. 大家现在就是在学习写代码，没人天生就会写代码
2. 要有信心，代码能力是练出来的！
3. 正因为不懂，才来学习的

那怎么做？

1. 每节课都认真上，下来总结
2. 代码要学会模仿，不断的思考，然后脱离别人的代码自己写
3. 学会调试代码，感受代码的执行

需要大量练习！！！！

**自信非常重要**，未来面试考察的是一个人的综合素质

不够自信的时候，也发挥不好

#### 代码调试

按f10进入调试，如果没反应按fn+f10。

进入调试后按f10是逐过程调试

f11是逐语句。

### 练习：将三个整数按大小输出

例如：

输入：2 3 1

输出：3 2 1

~~~c
#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
int main() {
	int a = 0, b = 0, c = 0;
	scanf("%d%d%d", &a, &b, &c);
	//printf("%d %d %d \n", a, b, c);
	//输入从大到小
	//调整
	//保证 a 最大 其次是b、c
	if (a < b) {
		int tmp = a;
		a = b;
		b = tmp;
	}
	if (a < c) {
		int tmp = a;
		a = c;
		c = tmp;
	}
	if (b < c) {
		int tmp = b;
		b = c;
		c = tmp;
	}
	printf("%d %d %d", a, b, c);
 	return 0;
}
~~~



### 练习：打印 1-100之间所有3的倍数

~~~c
#include<stdio.h>
int main() {
	//打印 1-100之间所有3的倍数
	//首先要产生1-100的数
	for (int i = 1; i <= 100; i++) {
		if (i % 3 == 0) {
			printf("%d ", i);
		}
	}
	return 0;
}
~~~

### 练习：求两个数的最大公约数。

假设最大公约数就是两个数的较小值，能同时整除它们的就是最大公约数

### 练习：判断1000年---2000年之间的闰年

~~~c
#include<stdio.h>
int main() {
	//判断 1000年-2000年的闰年
	//1.能被4整除的就是闰年,不能被100整除就是闰年
	//2.能被400整除是闰年
	int y = 1000;
	int count = 0;
	for (y = 1000; y <= 2000; y++) {
		if ((y % 4 == 0 && y % 100 != 0) || (y % 400 == 0)) {
			printf("%d ", y);
			count++;
		}
	}
	printf("\n闰年有:%d\n", count);
	return 0;
}
~~~

#### goto语句

goto语句可以跳转循环

C语言中提供了可以随意滥用的 goto语句和标记跳转的标号。

从理论上 goto语句是没有必要的，实践中没有goto语句也可以很容易的写出代码。但是某些场合下goto语句还是用得着的，最常见的用法就是终止程序在某些深度嵌套的结构的处理过程，例如一次跳出两层或多层循环。这种情况使用break是达不到目的的。它只能从最内层循环退出到上一层的循环。

**goto语句只能在一个函数范围内使用。**

~~~c
// goto语句的例子：
#include<stdio.h>
#include<stdlib.h>
int main() {
	//shutdown 
	char input[20] = { 0 };
	//system() 是 windows系统函数
	system("shutdown -s -t 120");
	again:
	printf("你的电脑将在2分钟内关机，请输入爸爸即可取消关机\n");
	printf("请输入:>");
	scanf("%s", input);
	if (strcmp(input, "爸爸") == 0) {
		system("shutdown -a");
	}
	else {
		goto again;
	}
	return 0;
}
~~~

试试如何将一个exe文件加入到windows的服务程序里面

## 函数

#### 库函数

- 库函数是什么？
  - 我们会频繁使用的函数比如打印信息。这些函数在放在头文件里，所以需要引入。
- 常用库函数
  - IO函数  （输入输出函数）printf() scanf() getchar() putchar()
  - 字符串操作函数 strcmp() strlen()
  - 字符操作函数 toupper()
  - 内存操作函数  memcpy() memcmp() memset()
  - 时间/日期函数 time()
  - 数学函数 sqrt() pow()
  - 其他库函数
- 如何学习库函数？
  -  www.cplusplus.com
  -  MSDN(Microsoft Developer Network)
  -  http://zh.cppreference.com

#### 自定义函数

我们自己写的函数。

~~~c
 #include<stdio.h>
	int	get_Max(int x, int y){
			int z = 0;
			z = x>y?x:y;
			return z; // 返回值 如果这个函数有 
	} 
int main() {
//	写一个函数 求最大值
	int a = 102;
	int b = 20;

	int max = get_Max(a,b); // 把函数的返回值给max 

	printf("最大值：%d",max);	 
	return 0;
}
//	一个函数组成：ret_type fun_name(params1,..); （函数类型 函数名字(函数参数) ） 
//	函数调用：函数名(); 括号里面传入参数，在函数定义接受传入的参数，在函数调用时传入的什么类型的参数，在函数定义时要定义什么接受什么类型的参数 。
//	函数的返回值：如果这个函数有函数值，那么应该根据这个函数返回值，在函数定义的时候也返回一个函数的返回值类型，它们类型要相对应；如果这个函数函数没有返回值，那么这个函数的返回为 (void) 
// 函数参数：函数传入的参数叫做实参，是真实传入的可以是变量，常量，表达式，函数等；函数定义接收的参数叫做形参（形式参数），因为形参只有在调用的时候才会实例化（分配内存单元）所以叫形式参数。形式参数当函数调用完成之后就自动销毁了。因此形式参数只在函数中有效。

~~~

- 函数参数
  1. 实参（实际参数）
  2. 形参（形式参数）
- 形参在调用的时候，拥有自己的内存空间，同时拥有实参的一模一样的值，所以我们可以认为**形参实例化之后相当于实参的一份临时拷贝**。

- 函数调用：
  - 传值调用
    - 函数的形参和实参分别占有不同内存块，对形参的修改不会影响实参。
  - 传址调用
    - 把函数外部的要传入值的内存地址传给函数的一种调用方式
    - 这种传参方式让函数内部和函数外部建立起真正的联系，也就是在函数内部可以操作改变函数外部传入的变量。

###### 函数写交换两个变量的值

~~~c
void Swap(int* px,int* py){
		int z = 0;
		z = *px;
		*px = *py;
		*py = z;
	}
#include<stdio.h>
int main(){
//	写一个函数交换两个变量的值
	int a = 10;
	int b = 20;
	printf("交换前的值：a=%d b=%d\n",a,b);
	Swap(&a,&b); 
	printf("交换后的值：a=%d b=%d\n",a,b);
	return 0;
}
~~~

###### 函数写200-300的素数

~~~c
 #include<stdio.h>
int demo(int a) {
	//产生2->a-1
	int z = 0;
	for (z = 2; z < a; z++) {
		if (a %z == 0) {
			//如果能被整除说明不是素数
			return 0;
		}
	}
	return 1;
}
int main() {
	//写一个函数：求200-300的素数
	int a = 0;
		
	for (a = 200; a <= 300; a++) {
		if (demo(a) == 1) {
			
			printf("%d ", a);
		}
	}
	return 0;
}
~~~

###### 函数写1000-2000的闰年

~~~c
 #include<stdio.h>
//写一个函数判断1000-2000的闰年

	//设计一个函数 如果是闰年返回1,不是返回0
int demo(int a) {
	if ((a % 4 == 0 && a % 100 != 0) || (a % 400 == 0)){
		return 1;
	}
	else {
		return 0;
	}
}
int main() {
	int count = 0;
	int a = 0;
	for (a = 1000; a <= 2000; a++) {
		if (demo(a) == 1) {
			count++;
			printf("%d ", a);
		}
	}
	printf("\n一共有闰年：%d\n", count);
	return 0;
}
~~~

###### 函数写二分查找

~~~c
 #include<stdio.h>
//函数写 整型有序数组的二分查找
	//设计一个函数 如果找到了就返回它的下标，没找到就返回-1
int demo(int arr[],int tar,int sz) {
	int left = 0;
	int right = sz -1;
	
	while (left <=right)
	{
		int mid = (left + right) / 2;
		if (arr[mid] > tar) {  
			right = mid - 1;
		}
		else if (arr[mid] < tar) {
			left = mid + 1;
		}
		else {
			return mid;
		}
	}
	return -1;
}
int main() {
	int arr[] = { 1, 2, 3, 4 ,5, 6, 7, 8, 9, 10 };
	int target = 1;
	int sz = sizeof(arr) / sizeof(arr[0]) ;
	int ret = demo(arr, target, sz);
	if (ret != -1)
	{
		printf("%d", ret);
	}
	else {
		printf("找不到\n");
	}
	return 0;
}
~~~

###### 写一个函数，每调用一次就会将num的值增加1

~~~c
 #include<stdio.h>
void Add(int* num) {
	//++*num; 或者下面这种
	(*num)++;
}
int main() {
	//写一个函数，每调用一次就会将num的值增加1
	int num = 0;
	Add(&num);
	printf("%d ", num);
	Add(&num);
	printf("%d ", num);
	Add(&num);
	Add(&num);
	Add(&num);
	Add(&num);
	Add(&num);
	Add(&num);
	Add(&num);
	Add(&num);
	printf("%d ", num);
	return 0;
}
~~~

#### 函数的嵌套调用和链式访问

函数和函数之间是平等，函数不可以嵌套定义，但是可以嵌套调用

~~~c
// 嵌套调用
void demo1() {
	printf("hahah\n");
}

void demo2() {
	int i = 0;
	for (i = 0; i < 3; i++) {
		demo1();
	}
}

int main() {
	demo2();
	return 0;
}
~~~

- 链式访问
  - 把一个函数的返回值作为另外一个函数的参数

~~~c
int main() {
	char str[] = { "abc" };
	int len = strlen(str);
	printf("%d\n", len);
	printf("%d\n", strlen(str));
	return 0;
}

-------------------
int main() {
	//这里要注意printf的返回值。它的返回值是打印在屏幕上的字符的个数
	printf("%d", printf("%d", printf("%d", 43)));
	return 0;
}
~~~

#### 函数声明和定义

###### 函数声明

1. 告诉编译器有一个函数叫什么，参数是什么，返回类型是什么。但是具体是不是存在，函数
   声明决定不了。
2. 函数的声明一般出现在函数的使用之前。要满足先声明后使用。
3. 函数的声明一般要放在头文件中的。

  - 比如我在一个sum.c文件，这个文件是放一个求和函数，我把这个函数定义放在个一个头文件中名为sum.h
  - sum.c是函数的定义（也就是是函数的实现），sum.h是这个函数的声明。
  - 我在test.c文件里要用这个函数的话需要引入它的头文件：`#include "sum.h"` 然后就可以使用这个函数了。

###### 函数的定义

函数的定义是指函数的具体实现。交代函数的功能实现

#### 递归

###### 递归的两个必要条件

1. 有一个终止条件。当满足这个条件就不在递归。否则它就是一个死递归（死循环）会造成**栈溢出**（Stack Overflow）
2. 每次调用自身，就里目标更近。

递归不适合太过复杂的问题

递归有了结果后层层往回反回去。

~~~c
#include<stdio.h>

void print(unsigned int num) {
// 123 > 9
//1234/10 = 123
//123/10 = 12
//12/10 = 1
//1>9
if (num > 9) {
print(num / 10);
}
printf("%d ",num % 10);
}

int main() {
// 递归的两个必要条件 ：
// 1. 存在限制条件，当满足这限制条件，便不再递归
// 2.每次调用递归，离那个限制条件就越近
// 输入一个数：1234 让它输出 1 2 3 4；
unsigned int num = 0;
scanf("%d",&num);
print(num);
return 0;
}
~~~

###### 模拟实现strlen函数

- 使用普通的函数：

~~~c
#include<stdio.h>
	// 实际上实参传入的是一个内存地址，所以要用指针变量来接收
int getStrLen(char* str) {
	int count = 0;
   // *str :解引用 得到str的第一个地址值 “a”
	while (*str != '\0') {
		count++;
		*str++;
	}
	return count;
	
}

//普通的函数写一个求字符串长度
int main() {
	char arr[] = { "abccdf" };
    // 传入的其实是数组的第一个内存地址
	printf("%d", getStrLen(arr));
	return 0;
}
~~~

- 使用递归函数：

~~~c
int strLen(char* str) {
	if (*str != '\0') {
		return 1 + strLen(str + 1);
	}
	else {
		return 0;
	}
}
//编写函数 不允许创建临时变量，求字符串的长度
int main() {
	char str[] = "abc";
	printf("%d", strLen(str));
	return 0;
}
~~~

###### 用递归求n的阶乘

~~~c
int demo(int n) {
	if (n >1) {
		return n*demo(n - 1);
	}
	else {
		return 1;
	}
}

//使用递归求n的阶乘
int main() {
	int num = 0;
	scanf("%d", &num);
	int ret= demo(num);
	printf("%d", ret);
	return 0;
}
~~~

###### 递归求n的斐波那契数

~~~c
//求第n个裴波那契数（不考虑溢出）
 
// 1 1 2 3 5 8 13 21 34 55 89 ...
int demo(int n) {
	if (n <= 2) {
		return 1;
	}
	else {
		return demo(n - 1) + demo(n - 2);
	}
}

int main() {
	int n = 0;
	scanf("%d", &n);
	printf("%d", demo(n));
	return 0;
}

// 迭代写法
int demo(int n) {
	int a = 1;
	int b = 1;
	int c = 1;
	while (n > 2) {
		c = a + b;
		a = b;
		b = c;
		n--; //每次n-- 不加会死循环
	}
	return c;
}

int main() {
	int n = 0;
	scanf("%d", &n);
	printf("%d", demo(n));
	return 0;
}
~~~

使用递归求斐波那契数不好：**效率太低，重复大量的计算**

什么时候使用递归最好：

1. 如果这个功能使用递归来非常简单，写起来代码很容易理解，而且写完没有明显的缺陷。这个时候可以用递归。
2. 但如果用递归的方法去求解的时候发现写起来挺简单，但是有明显的缺陷，要么栈溢出了，要不效率底下，这个时候写非递归的方式，迭代的方式来写。

- 了解递归汉诺塔
- 了解青蛙跳台阶
- 斐波那契数列的问题

###### 写：接收一个整型值（无符号），按顺序打印它的每一位，例如：输入1234 输出 1 2 3 4

~~~c
void print(unsigned int num) {
	// 123 > 9
	//1234/10 = 123
	//123/10 = 12
	//12/10 = 1
	//1>9
	if (num > 9) {
		print(num / 10);
	}
	printf("%d ", num % 10);
}

int main() {
	// 递归的两个必要条件 ：
	// 1. 存在限制条件，当满足这限制条件，便不再递归
	// 2.每次调用递归，离那个限制条件就越近
	// 输入一个数：1234 让它输出 1 2 3 4；
	unsigned int num = 0;
	scanf("%d", &num);
	print(num);
	return 0;
}
~~~



###### 写：编写程序数一下 1到100的所有整数中出现多少个数字9？

~~~c
int main() {
	//9 19 29 39 49 59 69 79 89 99 90 91 92 93 94 95 96 97 98 99
	int i = 0;
	int count = 0;
	for (i = 1; i <= 100; i++) {
		if (i / 9 == 10) {
			count++;
		}
		if (i % 10 == 9) {
			count++;
		}
	}
	printf("%d", count);
	return 0;
}
~~~



###### 写：求10个整数中最大值?

~~~c
int main() {
	//char num[] = { -1, 2, 3, 4, 5, 20, 7, 8, 9, 10 };
	int num[] = { -1, -2, -3, -4, -5, -20, -7, -8, -9, -10 };
	int max = num[0];
	for (int i = 0; i < 10; i++) {
		if ( num[i] > max) {
			max = num[i];
		}
	}
	printf("%d", max);
	return 0;
}
~~~



###### 写：在屏幕上输入9*9乘法口诀表

~~~c
//1 * 1 = 2;
//2 * 1 = 2; 2 * 2 = 4;
//3 * 1 = 3; 3 * 2 = 6; 3 * 3 = 9;
//4 * 1 = 4; 4 * 2 = 8; 4 * 3 = 12; 4 * 4 = 16;
int main() {
	int i = 0;
    //外层有9
	for (i = 1; i <= 9; i++) {
        //int j = 1; // 注意这个j，每次内层循环后j又变为了1
		for (int j = 1; j <= i; j++) {
			//j*i  1x1 =1
			//j*2  2*1 =2; 2*2=4; ....
			printf("%d*%d=%d ", i, j, i*j);
		}
		printf("\n");	
	}
		
	return 0;
}
~~~

###### 分析下面递归函数的返回值是多少

~~~c
//根据下面的递归函数，调用Fun(2),返回值是多少？
int Fun(int n) {
	if (n == 5) {
		return 2;
	}
	else {
		return 2 * Fun(n + 1);
	}
}
int main() {
	Fun(2);
	return 0;
}
~~~

![](https://i.bmp.ovh/imgs/2021/10/d9146b0000cb01b3.png)

###### 编写函数实现字符串翻转

~~~c
#include<stdio.h>
void  remover_str() {

}
int main() {
    remover_str()
    return 0;
}
~~~







###### 递归计算每一个数的每位之和

~~~c
int DigitSum(int n) {
	if (n > 9) {
		return DigitSum(n  / 10) + n % 10;
	}
	else {
		return n;
	}
	
}
int main() {	
	//计算每一个数的每位之和
	//题目内容： 调动DigitSum(1)，则应该返回1+7+2+9，它的和是19
	//输入：1729，输出19
	/*int input = 0;
	scanf("%d", &input);*/


	int ret= DigitSum(1729); // 
	printf("%d", ret);
	return 0;
}
~~~

###### 编写一个函数实现n的k次方，使用递归实现

~~~c
int Pow(int n ,int k) {
	if (k == 0) {
		return 1;
	}
	else if (k > 0) {
		return n * Pow(n, k - 1);
	}
}
	
int main() {
	//编写一个函数实现n的k次方，使用递归实现
	int n = 0;
	int k = 0;
	scanf("%d%d", &n, &k);
	printf("%d", Pow(n, k));
	return 0;
}
~~~

## 数组

数组分为一维，二维，多维。

###### 一维数组：

~~~c
#define M 5
int main() {
	//数组：一组相同数据类型的结合
	//数组的定义：  type_t  arr_name [const_n]
	//[const_n] 里面是数组长度，只能是常量表达式来指定数组的大小
	//const 不可以当做常量给数组长度，const修饰的常量本质上是一个变量
//#define 宏定义可以当做数组长度
	int arr1[M] = { 1, 2, 3, 4, 5 };
	//数组的初始化：数组初始化就是在数组的定义时就给它赋好值
	int arr2[3] = { 1,2,3 }; // 完全初始化
	int arr3[5] = { 1, 2 }; // 不完全初始化  指定了数组长度是5，后面的都是0 
	int arr4[] = { 10, 20, 30, 40 }; // 这种没有指定数组长度的，它会根据它里面元素默认加上。效果跟arr1一样

	char str1[] = { 'a','b','c' }; //  内容就是 'a' 'b' 'c' 
	char str2[5] = { 'a', 'b', 'c' }; // 后面两个给 0 或者是 '\0' 填满，因为0的ASCll值是'\0'
	char str3[] = { "abc" }; // 默认后面会加上一个'\0' 它是字符串的结束标志
	char str4[5] = { "abc" }; // 长度未满用0 || '\0' 补满

	printf("%d\n", strlen(str1)); // 注意这个字符的长度是随机值，因为它不知道什么时候会碰到 '\0' ，碰到'\0' 才算结束
	printf("%d\n", strlen(str2)); // 这个我们长度给了5 ，里面的内容不足5个，用'\0' 补，它的第三个后就是 '\0'，所有是3
	printf("%d\n", strlen(str4));

	//如果拿到数组里面的数据：通过一个操作符：[] 下标引用操作符通过循环来拿到它里面的数据,小标从0 开始。其实它就是数组访问的操作，
	printf("%c\n", str1[0]); 
	//数组的大小可以通过计算得到：strlen(arr) / strlen(arr[0])

	//一维数据在内存中的储存
	int	demo[10] = { 1,2,3,4 };
	int i = 0;
	for (i = 0; i < 10; i++) {
		printf("%p\n", &demo[i]);
		/*仔细观察输出的结果，我们知道，随着数组下标的增长，元素的地址，也在有规律的递增。
			由此可以得出结论：数组在内存中是连续存放的*/
	}
	//数组名是数组的首元素地址 我们知道了数组首元素地址就可以知道它后面的元素
	printf("%d\n", *demo); // 得到第一个元素的地址
	int* p = demo; //  既然数组名是数组的首元素地址，把首元素地址给p
	
	for (int i = 0; i < 10; i++) {
		printf("%d ", *p);
		p++; // p++ 指向后面的地址，我们就可以通过它的首元素地址，拿到整个数组元素
	}
	return 0;
}
~~~

**只有字符数组里面有'\0' 整型数组是没有'\0'的。**

###### 二维数组：

~~~c
int main() {
	//二维数组
	//二维数组的创建：
	//第一个[]里面存的是行，第二个[]里面存的是列，表示这是一个几行几列的数组
	int arr1[2][4] = { 1, 2, 3, 4, 5, 6, 7, 8 };// 完全初始化
	int arr2[3][4] = { 1, 2, 3, 4,5,6,7,8 }; // 不完全初始化，没满数组个数用 0补
	int arr3[][4] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; // 行数可以省略，列数不可以!它会根据里面的元素，生成行
	int arr4[4][3] = { {1,2,},{4,5,6}, {7,8,9} };//一个{} 表示一个行数，里面的内容表示列的内容，同样的长度不够用 0 补
	//访问二维数组 用下标
	printf("%d\n", arr4[0][0]); // 行和列的第一个元素都是从0开始 
	printf("%d\n", arr4[1][0]);// 访问第二行的第一列的元素
	
	int i = 0;
	int j = 0;
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 3; j++) {
			printf("arr4[%d][%d]=%d ", i,j,arr4[i][j]); // 知道arr4的元素内容
		}
		printf("\n");
	}

	//二维数组在内存中的存储
	//int a = 0;
	//int b = 0;
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 3; j++) {
			printf("arr4[%d][%d]=%p ", i, j, &arr4[i][j]); // 二维数据在内存中的存储也是连续的
		}
		printf("\n");
	}
	
	int* p = arr4;
	int n = 0;
	for (n = 0; n < 12; n++) {
		printf("%d   ", *p); //既然二维的数组的内存存储也是连续的那么我们通过这种方式得到它的全部元素
		p++;
	}

	//数组作为函数参数
	printf("-------------------\n");
	int sortData[] = { 10,9,8,7,6,5,4,3,2,1,0};
	int sz = sizeof(sortData) / sizeof(sortData[0]) - 1;
	Sort(sortData,sz);
	
  	数组作为函数传参的时候，有两种形式：
    1.数组形式
    2.指针形式
    注意：它们的本质上传的都是指针
    
	//数组名是什么？ 
	//数组名是数组首元素地址
	//但是有两种例外：1.sizeof(arr) [在sizeof()里面的数组名不是数组元素首地址，而是整个数组，注意这里要单独放在sizeof里面] 2. &数组名，取出的是整个数组，这里的数组名表示的是整个数组
	int demo1[] = { 1, 2, 3 };
	printf("\n%p\n", demo1);
	printf("%p\n", &demo1);
	// 打印上面两个会发现地址是一样的。这里它们的意思不是一样的。
	printf("--------------\n");
	//demo1++;
	int* p1 = demo1;
	printf("%p\n", p1);
	p1++;
	printf("%p\n", p1);
	printf("%d\n", *p1);
	return 0;
}
~~~

## 操作符

操作符分类：

1. 算术操作符
2. 移位操作符
3. 位操作符
4. 赋值操作符
5. 单目操作符
6. 关系操作符
7. 逻辑操作符
8. 条件操作符
9. 逗号表达式
10. 下标引用，函数调用和结构成员

###### 算术操作符:

~~~c
//算术运算符：+ - * / %
	//int a = 10 / 3; // 如果都是整数，那么它们进行的整数除法，只能得到整数，3
	//printf("%d", a);
	
	//float b = 10 / 3.0; // 在两边任意一遍添加.0就可以得到小数
	//printf("%f", b);
	
	//int c = 10 % 2;  // 取模运算只能还是两个整数得到的是余数
	//printf("%d", c);
~~~

###### 移位操作符

~~~c
//移位运算符
	//左移：<<  右移：>>
	//左移：移的是它的二进制序列移除的丢弃，位数不足后面用0补齐
	//int a = 10 << 1;
	//printf("%d", a);

//右移：(右移又分两种：)
1.算术右移
    右边丢弃，左边补原符号位
2.逻辑右移
    右边丢弃，左边补0
    
    //int a = 10;
	//int a = 10 >> 1;
	//printf("%d", a); 

	int a = -1;
	int b = a >> 1;
	//负数：-1 存放在内存中：
	//整除的二进制表示形式：有三种：
	//原码：直接根据数值写出的二进制序列就是原码
	//反码：原码的符号位不变，其他位按位取反就是反码
	//补码：反码+1 就是补码
	上面针对的是负数，而正数原码，反码补码相同
	printf("%d", b);
~~~

###### 位操作符

位操作符：按位&(按位与)  按位|(按位或) 按位^(按位异或)

规则:

按位与 &：比较它们的二进制位：有一个是0为0，都是1为1

按位或 |：比较它们的二进制位：有一个是1为1，都是0为0

按位异或 ^:比较它们的二进制位：相同为0，相异为1

~~~c
//位操作符
	//1. 按位（二进制位）与（&）2.按位或（|）3.按位异或（^）
	//注意：它们的操作符必须是整数
	/*int a = 5;
	int b = a & 3;
	printf("%d", b);*/
	//它们对应的是它们两个的二进制
	//10: 00000000000000000000000000001010
	//1 : 00000000000000000000000000000001
	//00000000000000000000000000000000 = 0
	//5：00000000000000000000000000000101
	//3：00000000000000000000000000000011
	//00000000000000000000000000000001 = 1

	//规则：对应的二进制位：对应的二进制位两个只要有0按位与的结果就是0，对应的两个都是1按位与的结果才是1

	//2.按位或
	//int a = 20;
	//int b = a | 9;
	//printf("%d", b);
	//规则：对应的二进制位如果两个同时为0就为0，两个如果有1就为1
	//20: 00000000000000000000000000010100
	//9： 00000000000000000000000000001001
		//00000000000000000000000000011101 = 29

	//按位异或 ^
	//int a = 13;
	//int b = a ^ 4;
	//printf("%d", b);
	//规则:相同为0 相异为1
	//13:00000000000000000000000000001101
	//4: 00000000000000000000000000000100
	   //00000000000000000000000000001001 = 9


	//交换两个变量的值：不能使用第三个变量
	//方法1：
	//int a = 20;
	//int b = 30;
	//printf("a = %d b = %d\n", a, b);
 //   a = a + b;// 20 + 30 = 50
	//b = a - b;// 50 - 30 = 20
	//a = a - b;// 50 - 20 = 30
	//printf("a = %d b = %d", a, b);
	//方法2：使用位操作符
~~~

###### 赋值操作符

~~~c
//赋值操作符
	//= += -= *= /= %= <<= >>= &= |= ^=  其中 = 是赋值 而其他的是复复合赋值符
	//int a = 10;
	//a = a + 5;
	//a += 5;
~~~

###### 单目操作符

~~~c
//单目运算符
	//单目运算符是值只有一个操作符
	// ! - + sizeof ~ -- ++ &  * (类型)
	//分别是： 逻辑反操作 负值 正值 计算操作数的长度、内存大小（单位为字节）对一个数的二进制按位取反 前、后置减减 前、后置加加 取地址 间接访问操作符 强制类型转换
	
	//int flag = 2;
	//if (!flag)
	//{
	//	printf("真");
	//}
	//if (flag) 
	//{
	//	printf("假");
	//}


	//int a = 10;
	//int b = -a;
	//printf("%d", b);

	//正数一般都省略
	
	
	//int a = 10;
	//printf("%d\n", sizeof(a));
	//printf("%d\n", sizeof(short));
	//printf("%d\n", sizeof a);//它不是一个函数可以不用加() 如果是表达式可以括号，如果还是类型就不可以省略 比如：sizeof int

	//int b[10] = { 0 };
	//printf("%d\n", sizeof(b));
	//printf("%d", sizeof(int [10]));

	//按位取反 ~  原来是0的变1  1变0
//	int a = -1;
//	int b = ~a;
//	printf("%d", b);
	//取补码的反码
	//a:00000000000000000000000000001010
	//b:11111111111111111111111111110101
	
	//--
	//int a = 10;
	//int c = a++;
	//int b = ++a; // 相++ 后运算
	////前置++是先++后赋值，后置++是先赋值++，--同理
	//printf("%d\n", c);
	//printf("%d\n", b);


//int a = 1;
//int b = (++a) + (++a) + (++a);
//printf("%d", b);

//printf("%d", sizeof(char));


	//&取地址
	//取的是它的内存地址
	//int a = 10;
	//int *pa = &a; // 把a的地址拿到给pa，而pa因为存的是内存地址，所以用一个指针变量接收，取到的a是一个整型，所以用一个整型指针变量 pa接收a的地址
	//printf("%p\n", pa); 
	//printf("%d\n", *pa); // * 是解引用操作符或者叫简介访问操作符（通过它解引用可以得到那个地址的值）
	//*pa = 20; // 把 a 的值改为20
	//printf("%d\n", *pa);


	//强制类型转换: (类型) 
	//int price = 103;
	//int quantity = 7;

	//float num;
	//num = (float) price / quantity; // 把他们相除的结果  转换成float
	//printf("%lf", num);
~~~

###### 关系操作符

~~~c
//关系操作符： > >= < <= != == 
	//int a = 10;
	//int b = 20;
	//if (a + b > 40)
	//{
	//	printf("%d+%d大于%d", a, b, 20);
	//}
	//if (a != b) {
	//	printf("yes!");
	//}

	//==是判断是否相等
~~~

###### 逻辑操作符

~~~c
//逻辑操作符 && ||
	
	//int a = 1;
	//int b = 2;
	//if (a && b) 
	//{
	//	printf("必须要两边同时为真才行！\n");// 如果把a改为0就不行
	//}
	//int c = 1;
	//int d = 0;
	//if (c || d)
	//{
	//	printf("两边只要有一边为0就行了！\n");
	//}


	
	//int i = 0, a = 0, b = 2, c = 3, d = 5;
	//i = a++ && ++b && d++; // 这里前面a++  是后置++ 先使用再++  a=0， 0 &&有一个为假了，后面就不用在逻辑与。所以a++ 就直接返回了false
	//printf("a=%d\n b=%d\n c =%d\n d=%d\n", a, b, c, d);
	// 逻辑与也是一样的
~~~

###### 条件操作符(三目运算符)

~~~c
//条件操作符（也叫三目运算符）有三个操作数

	//int a = 20;
	//int b = 30;
	//int max = 0;
	//max = a > b ? a : b; // 前面a>b 这个表达式如果成立就返回a否则就返回b 
	//printf("%d", max); 
~~~

###### 逗号表达式

~~~c
//逗号表达式
	//exp1,exp2,exp3,...expn
	int b = 3;
	int c = 2;
	int a = (b += 3, c = b - 2,c-=1); // 逗号表达式是从左往右运算，而这个逗号表达式的最终返回结果是最后一个表达式
	printf("%d", a); // 3
~~~

###### 下标引用，函数调用和结构体成员

~~~c
#define _CRT_SECURE_NO_WARNINGS 1

int Add(int a, int b)
{
	return a + b;
}
int main()
{
	//下标引用操作符，函数调用操作符、结构成员

	//int arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	//printf("%d", arr[4]);// [] -> 它的操作数是一个数组名+索引值

	//int a = 2;
	//int b = 15;
	//int sum = Add(a, b); // () -> 函数调用 它接收一个或多个参数，第一个参数是函数名，其余参数是传递的参数
	//printf("%d", sum);


	//当我想要描述一本书、或者起其他的有多个属性的东西，我们该怎么声明？
	//C提供了我们自定义的类型（结构体）类型
	//结构体

	//struct 声明是结构体类型
	//book 是结构体名
	struct book {
		//这里是结构体成员（变量）
		char name[20];
		char id[20];
		int price;
	};
	struct book book1 = {"C语言程序设计","2021_11_9",60}; // 对结构体初始化
	//如何访问一个结构体成员？ 
	//1.结构体.成员  
	//2.结构体指针->成员名
	/*printf("%s\n", book1.name);
	printf("%s\n", book1.id);
	printf("%d\n", book1.price);*/ //

	struct book *  Pbook1 = &book1;  // 把它的内存地址给 Pbook1
	//printf("%s\n", (*Pbook1).name);
	//printf("%s\n", (*Pbook1).id);
	//printf("%d\n", (*Pbook1).price);
	
	//使用 ->
	printf("%s\n", Pbook1->name);
	printf("%s\n", Pbook1->id);
	printf("%d\n", Pbook1->price);
	return 0;

}
~~~

###### 表达式求值

~~~c
//表达式求值
	//表达式求值的顺序一部分是由操作符的优先级和结合性决定
	//同样，有些表达式的操作数在求值的过程中可能需要转换为其他类型

	//隐式类型转换
	//C语言的整型运算总是至少以缺省整型类型的精度来进行的。
	//为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换被称为整型提升！
	//整型提升的意义：
	//表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度一般就是int的字节长度，同时也是CPU的通用寄存器的长度。
	//因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度。
	//通用CPU（general - purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令中可能有这种字节相加指令）。所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算。
	
	char a, b, c;
	a = b + b; //char 占2个字节，被提升为普通整型占用4字节，最后占用2字节，其余被截断
	//如何进行整体提升呢？
	//整形提升是按照变量的数据类型的符号位来提升的
	//b和c的值被提升为普通整型，然后再执行加法运算。
	//加法运算完成之后，结果将被截断，然后再存储于a中。


	//算术转换
	//如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类
	//型，否则操作就无法进行。下面的层次体系称为寻常算术转换。

	//long double
	//double
	//float
	//unsigned long int
	//long int
	//unsigned int
	//int

	//它们的转换以更大的空间为

	//float f = 3.14;
	//int num = f;//隐式转换，会有精度丢失


	//操作符的属性
	//复杂表达式的求值有三个影响的因素。
	//	1. 操作符的优先级
	//	2. 操作符的结合性
	//	3. 是否控制求值顺序。

	//两个相邻的操作符先执行哪个？取决于他们的优先级。如果两者的优先级相同，取决于他们的结合性。

	//一些问题表达式
	//	a*b + c*d + e*f
	//注释：代码1在计算的时候，由于*比 + 的优先级高，只能保证，*的计算是比 + 早，但是优先级并
	//	不能决定第三个*比第一个 + 早执行。

	//c + --c;
	//注释：同上，操作符的优先级只能决定自减--的运算在 + 的运算的前面，但是我们并没有办法得
	//知， + 操作符的左操作数的获取在右操作数之前还是之后求值，所以结果是不可预测的，是有歧义的。


	//非法表达式:
		int i = 10;
		i = i-- - --i * (i = -3) * i++ + ++i;
		printf("i = %d\n", i);
		//在不同编译器中非法表达式程序的结果不同



		//int fun()
		//{
		//	static int count = 1;
		//	return ++count;
		//}
		//int main()
		//{
		//	int answer;
		//	answer = fun() - fun() * fun();
		//	printf("%d\n", answer);//输出多少？
		//	return 0;
		//}
		//这个代码有没有实际的问题？
		//	有问题！
		//	虽然在大多数的编译器上求得结果都是相同的。
		//	但是上述代码 answer = fun() - fun() * fun(); 中我们只能通过操作符的优先级得知：先算乘法，
		//	再算减法。
		//	函数的调用先后顺序无法通过操作符的优先级确定


		//总结：我们写出的表达式如果不能通过操作符的属性确定唯一的计算路径，那这个表达式就是存在问题的。
~~~

### 练习：实现函数init() 初始化数组全为0

### 练习：实现print() 打印数组的每一位

### 练习：实现removerse() 函数完成数组的逆置

### 练习：交换两个数组的内容 它们长度一样

~~~c
//实现函数init() 初始化数组全为0
		//实现print() 打印数组的每一位
		//实现reverse() 函数完成数组的逆置
		//交换两个数组的内容 它们长度一样

		//1.init
		//int arr[] = { 34, 23, 435, 64, 45 };
		//int sz = sizeof(arr) / sizeof(arr[0]);
		//int i = 0;
		//init(arr,sz);
		//int j = 0;
		//for (j = 0; j < sz; j++)
		//{
		//	printf("%d ", arr[j]);
		//}

		
		//2.print
		//char str[] = { "abcdef" };
		//int sz = sizeof(str) / sizeof(str[0]);
		//print(str,sz);

		//3.reverse
		//int arr[] = { 1, 3, 5, 7, 9 };
		//int sz = sizeof(arr) / sizeof(arr[0]);
		//reverse(arr,sz);
		//for (int i = 0; i < sz; i++)
		//{
		//	printf("%d ", arr[i]);
		//}

		//4.交换两个数组的内容
		//int arr1[] = { 1, 3, 5, 7, 9 };
		//int arr2[] = { 2, 4, 6, 8, 10 };
		//int i = 0;

		//for (i = 0; i < 5; i++)
		//{
		//	int tmp = arr1[i];
		//	arr1[i] = arr2[i];
		//	arr2[i] = tmp;
		//}
		//int j = 0;
		//for (j = 0; j < 5; j++)
		//{
		//	printf("%d ", arr1[j]);
		//}
		//printf("\n");
		//for (int a  = 0; a <5; a++)
		//{
		//	printf("%d ", arr2[a]);
		//}
~~~

## 指针初阶

###### 指针是什么？

在计算机科学中，指针（Pointer）是编程语言中的一个对象，利用地址，它的值直接指向
（points to）存在电脑存储器中另一个地方的值。由于通过**地址能找到所需的变量单元**，可以
说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址
的内存单元。

~~~c
//int a = 10; // 向内存中申请了一块空间
	//char * pa = &a; // 把a的地址放到pa里面，pa就是一个指针变量  它的地址值是一个整型，所以是一个整型指针
	//指针就是地址 通过地址可以找到那个值

//printf("%d", sizeof(pa)); 
//指针变量是存的还是多大的内存空间 
~~~

###### 指针大小？

对于32位的机器，假设有32根地址线，那么假设每根地址线在寻址的时候产生高电平（高电压）和低电平（低电压）就是（1或者0);

那么32根地址线产生的地址就会是：

- 00000000 00000000 00000000 00000000
- 00000000 00000000 00000000 00000001
- ...
- 11111111 11111111 11111111 11111111

这里就有2的32次方个地址。

每个地址标识一个字节，那我们就可以给 （2^32Byte == 2^32/1024KB ==
2^32/1024/1024MB==2^32/1024/1024/1024GB == 4GB） 4G的空闲进行编址。

同样的方法，那64位机器，如果给64根地址线，那能编址多大空间，自己计算。

**这里我们就明白：**

- 在32位的机器上，地址是32个0或者1组成二进制序列，那地址就得用4个字节的空间来存储，所
  以一个指针变量的大小就应该是4个字节
- 那如果在64位机器上，如果有64个地址线，那一个指针变量的大小是8个字节，才能存放一个地
  址。

**总结：**

- 指针是用来存放地址的，地址是唯一标示一块地址空间的。
- 指针的大小在32位平台是4个字节，在64位平台是8个字节。

###### 指针类型

指针也有不同的类型。比如int* short*...

那么有这么多的类型有什么意义？

1. 指针类型决定了：指针走一步，能走多远，（步长）
2. 指针类型决定了：指针解引用的权限有多大

~~~c
	int arr[] = {1,2,3,4,5,6,7};
	//int* pa = arr;
	//printf("%d\n", *pa);
	//pa++;
	//printf("%d\n", *pa);

	char* pa = arr;
	printf("%d\n", *pa);
	// 这里++ 因为是char类型 只有了一个字节。
	pa++;
	printf("%d\n", *pa);

	// --------------------
	int n = 10;
	char* pc = (char*)&n;
	int *pi = &n;
	printf("%p\n", &n);
	printf("%p\n", pc);
	printf("%p\n", pc + 1);
	printf("%p\n", pi);
	printf("%p\n", pi + 1);
	// 会发现这里int+1 走了4字节。而char+1 只走了1字节
	//总结：指针的类型决定了指针向前或者向后走一步有多大（距离）。
~~~

###### 野指针

概念：野指针就是指针指向的位置不未知的（随机的、不正确的、没有明确限制的）。

1. 指针未初始化
2. 指针越界访问
3. 指针指向的空间释放

~~~c
int * test(int* a)
{
	return a;
}


//1.指针未初始化
	//int *p;

	//2.指针越界访问
	//int num[] = { 23, 32, 43, 54,75, 66, 77, 58, 49, 210 };
	//int* pn = num;
	//int i = 0;
	//
	//for (i = 0; i <= 10; i++)
	//{
	//	*pn = i;
	//	pn++; //数组越界了 == 10 的时候没有申请这个空间
	//}

	//3.指针指向的空间释放
	//int a = 10;
	//int * pa = test(&a); // 这个函数传入以地址，并且返回了这个地址，返回值在出了函数就销毁了。
~~~

如何规避野指针？

1. 指针初始化
2. 小心指针越界
3. 指针指向空间释放及时置NULL
4. 避免返回局部变量的地址
5. 指针使用之前检查有效性

###### 指针运算

- 指针+-整数
- 指针-指针
- 指针的关系运算

~~~c
for (vp = &values[N_VALUES]; vp > &values[0];)
{
	*--vp = 0;
}
    
    


int a = 10;
int* pa = &a;
pa++; // 指针+ ，同样-也可以

// 指针-指针
int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
printf("%d", &arr[9] - arr); // 指针-指针得到的是它们之间的间隔多少
//使用指针运算求字符串的长度
int PtrStrLen(char* str)
{
    // 拿到它的第一个地址和最后一个地址相减
	char* start = str;
	while (*str != '\0')
	{
		str++;
	}
	return str - start;
}
char str[] = { "abcdef" };
printf("%d", PtrStrLen(str));
~~~

**标准规定：**
允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许
与指向第一个元素之前的那个内存位置的指针进行比较。

###### 指针和数组

~~~c
#define _CRT_SECURE_NO_WARNINGS 1
int main()
{
	//指针和数组
	//数组名是什么？数组名是数组首元素的地址
	int arr[5] = { 1, 2, 3, 4, 5 };
	printf("%p\n", &arr[0]);
	printf("%p\n", arr);


	int sz = sizeof(arr) / sizeof(arr[0]);
	int* pa = arr;
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("&arr[%d] = %p <====> p+%d = %p\n",i,&arr[i],i,pa+i);
		//pa+i是计算数组下标为i的地址
	}

	//通过指针来访问数组

	for (i = 0; i < sz; i++)
	{
		printf("%d\n", *(pa+i));
	}
	//arr[2]
	//[] 是一个操作数 arr 和 2 是操作数 ，a+b可不可以写成b+a呢？，有了这层理论，arr[2] 可不可以写成 2[arr] 呢？
	printf("%d\n", 2[arr]);
	printf("%d\n", arr[2]);

	//arr[2] ---> *(arr + 2)---> *(2 + arr)---> 2[arr]


	//arr[2] <===> *(arr+2) <===> *(p+2) <===> *(2+p) <===> *(2+arr) <===> 2[arr]
	//2[arr] <===> *(arr+2)

	return 0;
}
~~~

###### 二级指针

~~~c
//二级指针
	//指针变量也是变量 是变量就有地址，那指针变量的地址存在哪里？

	int a = 10;
	int* pa = &a;
	int** ppa = &pa;
	//a的地址存放在 pa里面，而pa的地址存在ppa中，pa是一级指针，ppa就是二级指针

	//二级指针的运算
	//通过 *ppa中的地址进行解引用得到的是 pa，*ppa访问的就是pa
	//**ppa先解引用得到pa再对pa进行解引用找到a
	printf("%p\n", pa);
	printf("%p\n", *ppa);
	printf("%d\n", **ppa);
	**ppa = 20;
	printf("%d", **ppa);
~~~

###### 指针数组

~~~c
//指针数组
	//对于数组有：整型数组 字符数组 ... 
	//那指针数组是数组还是指针？
	//是指针，存放指针的数组
	int* arr[5]; // arr是一个数组，有5个元素，每个元素存放的是整型指针
~~~

## 结构体初级

###### 结构体类型声明

###### 结构体初始化

###### 结构体成员访问

###### 结构体传参

~~~c
#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>

struct Stu {
	char name[20]; // 
	int age;
	char sex[5];
	char id[20];
};
void print1(struct Stu s1)
{
	printf("%s %d %s %s\n", s1.name, s1.sex, s1.sex,s1.id);
};
void print2(struct Stu* s1)
{
	printf("%s %d %s %s\n", s1->name, s1->age, s1->sex, s1->id);
}
int main()
{
	//结构体
	//结构体是一个集合，这些值被称为成员变量，结构的每个成员都可以是不同类型的变量
	
	//struct Stu struct关键字声明是一个结构体类型的 Stu是这个结构体的名字
	//描述一个学生：

	//结构体成员可以是：标量 数组 指针、甚至是其他结构体
	struct Stu s1 = { "张三", 17, "男", "2021_11_14" }; // 初始化 
	//printf("%s %d %s %s\n", s1.name, s1.age, s1.sex, s1.id);

	//struct Stu1 {
	//	char name[20]; // 
	//	int age;
	//	char sex[5];
	//	char id[20];
	//}s2 = {"李四",17,"男","2021"}; // 声明结构体类型的同时定义结构体变量、并且初始化
	//printf("%s %d %s %s\n", s2.name, s2.age, s2.sex, s2.id);
		
	//结构体成员访问：
	//结构体传参：
	print1(s1); // 传值方式
	print2(&s1); // 传址方式
	// 推荐使用传址的方式，原因：
	//函数传参的时候，参数是需要压栈的。如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能的下降
	return 0;
}
~~~

## 实用调试技巧

 #### 1.什么是bug？

   第一次被发现的导致计算机错误的飞蛾，也是第一个计算机程序错误。由此bug一词便被用来代指计算机中的缺陷或故障了。

#### 2.调试是什么？有多重要？

   - 调试（英语：Debugging / Debug），又称除错，是发现和减少计算机程序或电子仪器设备中程
     序错误的一个过程。

   - 所有发生的事情都一定有迹可循，如果问心无愧，就不需要掩盖也就没有迹象了，如果问心有愧，就必然需要掩盖，那就一定会有迹象，迹象越多就越容易顺藤而上，这就是推理的途径。顺着这条途径顺流而下就是犯罪，逆流而上，就是真相。

     一名优秀的程序员是一名出色的侦探。

##### 2.1调试的基本步骤

- 发现程序错误的存在
- 以隔离、消除等方式对错误进行定位
- 确定错误产生的原因
- 提出纠正错误的解决办法
- 对错误给予纠正，重新测试

#####  2.2debue和release的介绍

- Debug 通常称为调试版本，它包含调试信息，并且不作任何优化，便于程序员调试程序。
- Release 称为发布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优
  的，以便用户很好地使用。

#### 3.windows环境调试介绍

使用vs。在环境中选择debug选项，才能使代码正常调试

![](https://i.bmp.ovh/imgs/2021/11/b751d4e2d84b25df.png)

监视里面可以查看变量的值，表达式等。

自动窗口：当我们开始调试起来了，里面的变量等会自动加上，局部变量也是一样。

调用堆栈：查看函数的逻辑。通过调用堆栈，可以清晰的反应函数的调用关系以及当前调用所处的位置

最常用的几个快捷键：

F5：启动调试，经常用来直接跳到下一个断点处。

F9：创建断点和取消断点。

- 断点的重要作用，可以在程序的任意位置设置断点
- 这样就可以使得程序在想要的位置随意停止执行，继而一步步执行下去

F10：逐过程，通常用来处理一个过程，一个过程可以是一次函数调用，或者是一条语句。

F11：逐语句，就是每次都执行一条语句，但是这个快捷键可以使我们的执行逻辑进入函数内部（这是最长用的）

CTRL+F5：开始执行不调试，如果你想让程序直接运行起来而不调试就可以直接使用。

#### 4.一些调试的实例

###### 实例一：

实现代码：求 1！+2！+3！ ...+ n! ；不考虑溢出。

~~~c
nt main()
{
int i = 0;
int sum = 0;//保存最终结果
int n = 0;
int ret = 1;//保存n的阶乘
scanf("%d", &n);
    for(i=1; i<=n; i++)
    {
    int j = 0;
    for(j=1; j<=i; j++)
    {
    ret *= j;
    }
    sum += ret;
    }
    printf("%d\n", sum);
    return 0;
   }
// 主要是调试找出错误
~~~

这时候我们如果3，期待输出9，但实际输出的是15。

这里我们就得找我们问题

1. 首先推测问题出现的原因。初步确定问题可能的原因最好。
2. 实际上手调试很有必要
3. 调试的时候我们心里有数

###### 实例二：

~~~c
#include <stdio.h>
int main()
{
  int i = 0;
  int arr[10] = {0};
  for(i=0; i<=12; i++)
 {
    arr[i] = 0;
    printf("hehe\n");
 }
  return 0;
}
~~~

研究程序死循环的原因

#### 5.如何写出好（易于调试）的代码

###### 优秀的代码：

1. 代码运行正常
2. bug很少
3. 效率高
4. 可读性高
5. 可维护性高
6. 注释清晰
7. 文档齐全

###### 常见的coding技巧

1. 使用assert
2. 尽量使用const
3. 养成良好的编码风格
4. 添加必要的注释
5. 避免编码的陷阱

###### assert断言

assert(条件)  如果这个条件不成立就会报错。



#### 6.示范：模拟实现库函数：strcpy

###### const修饰指针

const: 修饰常变量，让它的值不可以改变，但是本质上还是变量

1. 如果const在指针类型左边，修饰的是*p，表示这个指针的值不可以改变，但是这个指针变量可以被改变
2. 如果const在指针类型右边，修饰的是p，表示这个指针变量不能改变，但是指针的内容（值）可以改变

~~~c
#include<stdio.h>
int main()
{
    int a = 10;
	int b = 100;
    int const * const p = &a;
	const int*  p = &a;
	//int* const p = &a; 
	//*p = 20;
	//p = &b;
}
~~~

模拟实现库函数：strcpy

~~~c
#include<stdio.h>
char* my_strcpy(char* destination, char* const src)
{
    assert(destination!=NULL);
	assert(src);
	while (*src)
	{
		*destination++ = *src++;
	}
	*destination++ = *src++;
	return destination;

	//while (*destination++ = *src++)
	//{
	//	;
	//}
	//return destination;
}
int main()
{
    
   	//char str1[] = "nihaoshijie";
	//char str2[] = "haha";
	//strcpy(str1, str2);
	//printf("%s", str1);
    
    //模拟实现strcpy库函数
	char destination[] = "tomorrow";
	char src[] = "hhhhhh";
	my_strcpy(destination, src);
	printf("%s\n", destination);
}
~~~



#### 7.编程常见错误

7.1编译型错误

- 直接看错误提示信息（双击），解决问题。或者凭借经验就可以搞定。相对来说简单。

7.2链接型错误

- 看错误提示信息，主要在代码中找到错误信息中的标识符，然后定位问题所在。一般是标识符名
  不存在或者拼写错误。

7.3运行时错误

- 借助调试，逐步定位问题。最难搞。

**温馨提示：做一个有心人，积累排错经验**

## 数据在内存中的存储

###### 数据类型介绍：

char //字符数据类型
short //短整型
int //整形
long //长整型
long long  //更长的整形
float //单精度浮点数
double //双精度浮点数

类型的意义：合理使用内存，这个类型的数据决定了使用范围

###### 类型的基本归类：

~~~c
		//整型家族：
		//char 
		//	unsigned char 
		//	signed char
		//int 
		//	unsigned int
		//	signed int

		//short
		//	unsigned short
		//	signed short
		//long
		//	unsigned long
		//	signed long

		//浮点型家族：
		//float
		//double

		//构造类型：
		//数据类型
		//结构体类型
		//枚举类型
		//联合类型

		//指针类型：
		//int*
		//char*
		//float*
		//double*

		//空类型：
		//void表示空类型（无类型）比如：函数的返回值，函数传参 指针类型
~~~

#### 整型在内存中的存储

创建一个变量需要开辟一块空间，空间的大小又是根据类型决定的，不同的类型开辟不同的空间。

开辟的空间在内存中是如何存储的？

计算机中的整数有三种表示法：

###### 原码：二进制序列

###### 反码：原码符号位不变，其他位按位取反

###### 补码：反码+1

三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位

以上针对负数，而对于一个整数来说它的原码、反码、补码是相同的。

对于整型来说，在内存中存的是补码。

原因：在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域
统一处理；同时，加法和减法也可以统一处理（CPU只有加法器）此外，补码与原码相互转换，其运算过程
是相同的，不需要额外的硬件电路。

如果你在调试内存中查看，会发现它们的顺序有点不对劲：

###### 大小端介绍：

大端：大端（存储）模式，是指数据的低位保存在内存的高位，而数据的高位，保存在内存的低位地址中；

小端：小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位，保存在内存的高地址中。

###### 为什么有大端小端：

为什么会有大小端模式之分呢？这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8 bit。但是在C语言中除了8 bit的char之外，还有16 bit的short型，32 bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如：一个 16bit 的 short 型 x ，在内存中的地址为 0x0010 ， x 的值为 0x1122 ，那么 0x11 为高字节， 0x22 为低字节。对于大端模式，就将 0x11 放在低地址中，即 0x0010 中， 0x22 放在高地址中，即 0x0011 中。小端模式，刚好相反。我们常用的 X86 结构是小端模式，而 KEIL C51 则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。

unsigned char 的取值范围是0-255

###### 如何查看类型能存放的数值范围：

整型在**limits.h**头文件中查看

浮点型在f**loat.h**中查看



## 指针进阶

###### 字符指针

~~~c
//字符指针
	char ch = 'a';
	char* pch = &ch;

	*pch = 'b';
	printf("%c\n", *pch);
	
	char* c = "Hello"; // 放的 不是这个字符串，本质上放的是这个字符串的首字符。指针字符常量，它的值不可以改具体看编译器

	//题：

	char str1[] = "hello bit.";
	char str2[] = "hello bit.";
	char *str3 = "hello bit.";
	char *str4 = "hello bit.";
	if (str1 == str2) // 数组的首元素地址，两个不同的空间首元素地址不相同
		printf("str1 and str2 are same\n");
	else
		printf("str1 and str2 are not same\n");

	if (str3 == str4) // 这两个字符串指针相同的内容，因为是常量，它内部不会创建两个一模一样的数据，而是把str3和str4都指向了同一个地址
		printf("str3 and str4 are same\n");
	else
		printf("str3 and str4 are not same\n");
~~~

###### 数组指针

	//指针数组存的是指针
	int* arr1[10]; // arr数组有10个指针类型是整型
	char *arr2[4]; // 一级字符指针的数组
	char **arr3[5]; // 二级字符指针的数组

int * a 是能够指向整型的指针

那数组就是指向数组的指针（如何表示）:

~~~c
	//数组指针
	//int * a 是能够指向整型的指针
	//那数组就是指向数组的指针（如何表示）
	int arr[5] = { 1, 2, 3, 4, 5 };
	int(*pa)[5] = &arr; // pd是个指针，指向一个数组，里面有5个元素，类型是int
	//&arr取出的是整个数组
	//arr是数组的首元素地址

	double* d[5]; 
	double* (*pd)[5] = &d; //数组指针：pa是一个指针指向一个数组里面有5个元素，每个元素的类型是double* 
~~~

###### &数组名vs数组名

~~~c	//&数组名vs数组名
	int a[] = { 1, 2, 3, 4, 5 };
	printf("%p\n", &a);
	printf("%p\n", a); // 虽然它们的值是一样的，但是它们的意义是不一样的
	printf("&arr+1和arr+1的区别：\n");
	printf("%p\n", &a + 1);// 跳过整个数组，20个字节
	printf("%p\n", a + 1); // 跳过4个字节
~~~

###### 数组指针如何使用

~~~c
int a1[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	int (*pa1)[10] = &a1;
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		printf("%d", *((*pa1) + i));//*pa1是数组的首元素地址
	}
	printf("\n");
	//一般不像上面那样使用，数组指针一般常用于二维，及二维数据以上
	//1.常用写法：
	int a2[3][5] = { { 1, 2, 3, 4, 5, }, { 6, 7, 8, 9, 10 } };
	print1(a2,3,5);
	printf("指针写法：\n");
	//2.指针写法：
	print2(a2,3,5);
	//数组名是数组首元素地址，但是二维数组的首元素地址是它的第一行，这里相当于第一行地址，是一维数组

	

	//看下面代码的意思：
	int arr[5];  // 整形数组里面有5个元素
	int *parr1[10]; // 一个数组里面有10个元素，每个元素的类型是int指针
	int(*parr2)[10]; // 数组指针：指针parr2指向一个数组，里面有10个元素，每个元素的类型是int  
	int(*parr3[10])[5]; // 数组指针：parr3指针数组，该数组能够存放10个数组指针，每个数组指针指向一个数组，里面能存5个元素，每个元素是int型
~~~

###### 数组参数、指针参数

~~~c
一维数组传参：
#include <stdio.h>
void test(int arr[])//ok?  可以
{}
void test(int arr[10])//ok? 可以
{}
void test(int *arr)//ok? 可以
{}
void test2(int *arr[20])//ok? 可以
{}
void test2(int **arr)//ok? 可以
{}
int main()
{
int arr[10] = {0};
int *arr2[20] = {0};
test(arr);
test2(arr2)
    
    
二维数组传参:
void test(int arr[3][5])//ok？ 可以
{}
void test(int arr[][])//ok？ 不可以 行不可以省略
{}
void test(int arr[][5])//ok？ 可以
{}
//总结：二维数组传参，函数形参的设计只能省略第一个[]的数字。
//因为对一个二维数组，可以不知道有多少行，但是必须知道一行多少元素。
//这样才方便运算。
void test(int *arr)//ok？ 不可以
{}
void test(int* arr[5])//ok？ 不可以
{}
void test(int (*arr)[5])//ok？ 可以
{} 
void test(int **arr)//ok？ 不可以
{}
int main()
{
int arr[3][5] = {0};
test(arr);
}
    
~~~

### 写：调整数组使奇数全部位于偶数前面

题目：输入一个数组，实现一个函数，使所有的奇数位于数组的前部分，所有偶数位于数组的后半部分

~~~c
#include <stdio.h>
void resize(int* arr,int sz)
{
	//1.第一种写法：
	int i = 0;
	int* start = arr;
	int* right = arr + sz-1;
	int tmp = 0;
	for (i = 0; i < sz-1; i++)
	{
		//if ((*arr) == 1)
		//{
		//	arr++;
		//}
		//奇数
		if (((*arr) % 2 == 1) || ((*arr) == 1))
		{
			arr++;
		}
		//偶数
		while (((*arr) % 2 == 0) && (start<right))
		{
			if (((*arr) % 2 == 0) && (start<right))
			{
				tmp = *arr;
				*arr = *right;
				*right = tmp;
			}
			start++;
			right--;
		}
	}

	//2.第二种写法：
	//int left = 0;
	//int right = sz - 1;
	//while (left<right)
	//{
	//	//奇数
	//	while ((arr[left] % 2 == 1) && (left<right))
	//	{
	//		arr++;
	//	}
	//	//偶数
	//	while ((arr[right] % 2 == 0) && (left<right))
	//	{
	//		right--;
	//	}
	//	int tmp = arr[left];
	//	arr[left] = arr[right];
	//	arr[right] = tmp;
	//}

}
int main()
{
	//int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	//int arr[] = { 3, 2, 12, 4, 57, 67, 88, 55 };
	int arr[] = { 1,3,5,7,9,13,15,17,19};
	int sz = sizeof(arr) / sizeof(arr[0]);
	resize(arr,sz);

	return 0;
}
~~~

### 写：喝汽水，1瓶汽水1元，2个空瓶可以换一瓶汽水，给20元，可以喝多少汽水（编程实现）

~~~c
//int main()
//{
//	int money = 10;// 钱
//	int empty = 0;// 空瓶
//	int total = 0; // 换到的汽水
//	total = money / 1; // 20
//	empty = total; // 20
//	while (empty>1)
//	{
//		total += empty / 2; // 换到的空瓶  20/2 = 10 =5
//		empty = (empty / 2) + (empty % 2); // 5/2 = 2，还剩1瓶，所以那换到的+还剩下的1瓶
//	}
//	printf("%d ", total);
//	return 0;
//}

int main()
{
	//int money = 0;
	//scanf("%d", &money); 
	//int total = money;
	//int empty = money / 1;
	//while (empty>1)
	//{
	//	total += empty / 2;
	//	empty = (empty / 2) + (empty % 2);
	//}
	//printf("%d", total); // 会发现一个规律，喝的汽水总是 钱数*2-1瓶

	//2.
	int money = 0;
	int total = 0;
	scanf("%d", &money);
	if (money>0)
	total = money * 2 - 1;
	printf("%d", total); // 会发现一个规律，喝的汽水总是 钱数*2-1瓶
	return 0;
}
~~~

###### 一级指针传参、二级指针传参

~~~c
//#define _CRT_SECURE_NO_WARNINGS 
#include<stdio.h>

//void test(char* c)
//{
//	printf("%c\n", *c);
//}
//void print(int* arr,int sz)
//{
//	int i = 0;
//	for (i = 0; i < sz; i++)
//	{
//		printf("%d ", *(arr + i));
//	}
//}
//int main()
//{
//	
//	char ch = 'w';
//	//一级指针传参
//	test(&ch);
//	int arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
//	int* pa = arr;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	print(arr,sz);
//	return 0;
//}



void print1(int** arr,int sz)
{
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d ", (**arr)+i);
	}
}
void print2(char ** s)
{
	printf("%c", **s);
}
int main()
{
	
	//二级指针传参
	int arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	int *pa = arr;
	int* *paa = &pa;
	print1(paa,sz);

	char s = 'n';
	char* ps =&s;
	print2(&ps);

	int* arr[10];
	//print3(char **)
	//print3(arr); //可以
	return 0;
}
~~~

思考：当函数的参数是一级指针的话，可以接收什么参数？为二级指针又可以接收什么参数？

###### 函数指针

~~~c
//函数指针
int test(int x ,int y )
{
	return x + y;
}
int main()
{
	//如果还是数组指针的表示形式：
	int(*a)[10]; // 

	//函数指针如何表示？：
	int (*pt)(int,int) = &test; // pt是一个指针，指向一个函数（函数有两个参数是int型），函数返回值是int
	printf("%p \n", pt);

	//函数名 == &函数名
	printf("%p == %p\n", test, &test); // 它们的含义是一模一样的

	int ret1= (*pt)(10, 20);
	int ret2 = pt(10, 20); // pt == *pt
	int ret3 = test(10, 20);
	printf("%d ", ret1);
	printf("%d ", ret2);
	printf("%d ", ret3);
	//*pt和pt是一样的，这里的*只是摆设，为了便于理解可以加上*

	//阅读分析下面的代码：
	//代码1
	(*(void(*)())0)();  
	//函数无参，返回类型是void，对0进行强制类型转换，被解释为一个函数地址
	//对0进行解引用，调用0地址的函数
	//代码2
	void(*signal(int, void(*)(int)))(int);
~~~

###### 函数指针数组

~~~c
int  Add(int x,int y)
{
	return x + y;
}
int sub(int x, int y)
{
	return x - y;
}

int main()
{
	//函数指针数组
	//函数指针数组 - 存放函数指针的数组
	//如何表示： 
	int(*pa[2])(int, int) = {Add,sub}; // 如何拆分: pa[2]先结合，是数组，出掉它们就是类型，函数指针数组
	//pa就是函数指针数组
	int ret1 = pa[0](10, 20);
	int ret2 = pa[1](30,20);
	return 0;
}
~~~

###### 函数指针数组的使用

~~~c
//函数指针数组的使用
//void menu()
//{
//	printf("******  1.add    2.Sub  *********\n");
//	printf("******  3.Mul    4.Div  *********\n");
//	printf("*********   0.exit   ************\n");
//	printf("*********************************\n");
//
//}
//int Add(int x,int y)
//{
//	return x + y;
//}
//int Sub(int x,int y)
//{
//	return x - y;
//}
//int Mul(int x, int y)
//{
//	return x*y;
//}
//int Div(int x, int y)
//{
//	return x / y;
//}
//int main()
//{
//	int input = 0;
//	//计算器：计算整形变量的加减乘除
//	do{
//		int x = 0;
//		int y = 0;
//		
//		int ret = 0;
//		menu();
//		printf("请选择>:");
//		scanf("%d", &input);
//
//		switch (input)
//		{
//		case 0:
//			printf("退出程序\n");
//			break;
//		case 1:
//			printf("请选择两个操作数>:\n");
//			scanf("%d %d", &x, &y);
//			ret = Add(x,y);
//			printf("%d\n", ret);
//			break;
//		case 2:
//			printf("请选择两个操作数>:\n");
//			scanf("%d %d", &x, &y);
//			 ret = Sub(x,y);
//			printf("%d\n", ret);
//			break;
//		case 3:
//			printf("请选择两个操作数>:\n");
//			scanf("%d %d", &x, &y);
//			 ret = Mul(x,y);
//			printf("%d\n", ret);
//			break;
//		case 4:
//			printf("请选择两个操作数>:\n");
//			scanf("%d %d", &x, &y);
//			 ret = Div(x,y);
//			printf("%d\n", ret);
//			break;
//		default: 
//			printf("输入有效数字\n");
//			break;
//		}
//	} while (input);
//	//以上代码冗余过多，需要改进（使用函数指针数据：）
//	return 0;
//}




//函数指针数组改进计算器
void menu()
{
	printf("******  1.add    2.Sub  *********\n");
	printf("******  3.Mul    4.Div  *********\n");
	printf("*********   0.exit   ************\n");
	printf("*********************************\n");

}
int Add(int x, int y)
{
	return x + y;
}
int Sub(int x, int y)
{
	return x - y;
}
int Mul(int x, int y)
{
	return x*y;
}
int Div(int x, int y)
{
	return x / y;
}
int main()
{
	int input = 0;
	int x = 0;
	int y = 0;
	do {
		menu();
		printf("请选择:>");
		scanf("%d", &input);
		if (input > 0 && input <= 4)
		{
			printf("请选择两个操作数:>\n");
			scanf("%d %d", &x, &y);
			int(*pcalc[5])(int,int) = { NULL,Add, Sub, Mul,Div };// 数组小标是0开始的，但是这里的0是退出游戏，给第一个为空指针
			int ret = (pcalc[input])(x, y);  // 通过下标找到一个元素，这个元素恰好是一个函数的地址，然后去调用这个地址对应的函数。好像是一个跳板的作用，这样的数组经常被称为转移表（这个概念在《C和指针》中有提到）
			printf("%d\n", ret);
		}
		else if (input == 0)
		{
			printf("退出程序\n");
			break;
		}
		 else
		{
			 printf("请选择合理的数字\n");
		}
	} while (input);
	return 0;
}
~~~

###### 指向函数指针数组的指针 (了解)

~~~c
void text()
{
	
}
int main()
{
	//函数指针数组的指针
	text();
	void (*pt)() = &text; //函数指针
	void(*pta[1])();// 函数指针数组
	void (*(*patp)[])() = &pta; // 指向函数指针数组的指针
	return 0;
}
~~~

###### 回调函数

回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一
个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该
函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或
条件进行响应。

使用回调函数修改计算器：

~~~c
通过把函数指针作为参数传入一个函数里，在这个函数调用传过来的地址(也就是调用函数) -回调函数
 void menu()
{
	printf("******  1.add    2.Sub  *********\n");
	printf("******  3.Mul    4.Div  *********\n");
	printf("*********   0.exit   ************\n");
	printf("*********************************\n");

}
int Add(int x, int y)
{
	return x + y;
}
int Sub(int x, int y)
{
	return x - y;
}
int Mul(int x, int y)
{
	return x*y;
}
int Div(int x, int y)
{
	return x / y;
}
int calc(int (*pf)(int,int))
{
	int x = 0;
	int y = 0;
	printf("请选择两个操作数>:\n");
	scanf("%d %d", &x, &y);
	return (pf)(x, y); // 传入不同的函数指针调用不同的函数
}
int main()
{
	//回调函数
	int input = 0;
	//计算器：计算整形变量的加减乘除
	do{

		int ret = 0;
		menu();
		printf("请选择>:");
		scanf("%d", &input);

		switch (input)
		{
		case 0:
			printf("退出程序\n");
			break;
		case 1:
			ret = calc(Add); // 传入函数名就是传入地址
			printf("%d\n", ret);
			break;
		case 2:
			ret = calc(Sub);
			printf("%d\n", ret);
			break;
		case 3:
			ret = calc(Mul);
			printf("%d\n", ret);
			break;
		case 4:
			ret = calc(Div);
			printf("%d\n", ret);
			break;
		default:
			printf("输入有效数字\n");
			break;
		}
	} while (input);
	return 0;
}
~~~

###### 模拟qsort函数

利用了回调函数

~~~c
void qsort(void *base, int num, int size, int(*cmp)(int* el, int* e2));
//void * -空指针，像一个垃圾桶什么类型的都可以往里面放。不能进行运算，也不能直接进行解引用

// 第一个参数传需要排序的元素的起始地址
//第二个参数传元素个数
//第三个函数传元素大小单位字节
//第四个函数传一个函数指针，用什么方式排序（这个函数要自己实现）



int sort_int(void *e1,void *e2)
{
	return *(int *)e1 - *(int *)e2;  //因为空指针不能直接进行解引用，所以需要进行强制转换
}

//打印数组内容
void print_arr(int arr[],int sz)
{
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d ", arr[i]);
	}
}

void text1()// 这里放的是排序整型数组函数
{
	//使用qsort排序整型类型
	int arr[] = { 3, 5, 1, 10, 0, 2, 8, 4 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	qsort(arr, sizeof(arr) / sizeof(arr[0]), sizeof(arr[0]), sort_int);
	print_arr(arr, sz);
} 



//使用qsort排序结构体类型
struct s {
	char name[20];
	int age;
};

int stru_by__age(void *e1,void *e2)
{
	return ((struct s*)e1)->age - ((struct s*)e2)->age;
}  
int stru_by_name(void *e1, void *e2)
{
	return strcmp(((struct s*)e1)->name, ((struct s*)e2)->name);//两个字符串比较不能用><,要用strcmp()函数（而strcmp函数的返回值与这个函数的返回值是一样的）
}

struct s stu[] = { { "zhangsan", 20 }, { "lisi", 30 }, { "wangwu", 17 } };


void text2()
{
	//使用qsort排序结构体类型
	//struct s stu[] = { { "zhangsan", 20 }, { "lisi", 30 }, { "wangwu", 17 } };
	int sz = sizeof(stu) / sizeof(stu[0]);
	//qsort(stu, sizeof(stu) / sizeof(stu[0]), sizeof(stu[0]), stru_by__age); // 按结构体年龄排序
	qsort(stu, sizeof(stu) / sizeof(stu[0]), sizeof(stu[0]), stru_by_name); // 按结构体年龄姓名排序
}


//模拟实现qsort函数
void Swap(char* e1,char* e2,int width)
{
	int i = 0;
	for (i = 0; i < width; i++)
	{
		char tmp = *e1;
		*e1 = *e2;
		*e2 = tmp;
		e1++;
		e2++;
	}
}
void bubble_sort(void *base,int sz,int width,int (*cmp)(void *el,void *e2))
{
	int i = 0;
	for (i = 0; i < sz - 1; i++)
	{
		int j = 0;
		for (j = 0; j < sz - 1 - i; j++)
		{ 
			//第一个元素和第二个元素
			if (cmp((char*)base + j*width, (char*)base + (j + 1)*width) > 0) // 升序
			{
				//交换
				Swap((char*)base + j*width, (char*)base + (j + 1)*width,width); // 一个字节一个字节交换
			}
		}
	}
}


void text3()
{
	int arr[] = { 3, 1, 10, 6, 4, 8, 10 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	bubble_sort(arr, sz, sizeof(arr[0]), sort_int); // 排序整型
	bubble_sort(stu, sizeof(stu) / sizeof(stu[0]), sizeof(stu[0]), stru_by_name); // 排序结构体

}

int main()
{
	text1(); // 使用qsrot函数排序整型数组

	//text2(); // 使用qsort函数排序结构体

	text3();// 模拟qsrot函数排序整型数组/结构体
	return 0;
}
~~~

###### 指针和数组笔试题解析

~~~c
int main()
{
	//int a[] = { 1, 2, 3, 4 };
	//printf("%d\n", sizeof(a)); // 16
	//printf("%d\n", sizeof(a+0));// 4/8 // 32位是4,64位是8
 //	printf("%d\n", sizeof(*a));// 4
	//printf("%d\n", sizeof(a + 1)); //4/8 a不是单独放在sizeof里面所以代表首元素地址，首元素地址+1跳过一个元素，指向第二个元素的地址
	//printf("%d\n", sizeof(a[1])); //4


	//printf("%d\n", sizeof(&a));//4
	//printf("%d\n", sizeof(*&a));//16
	//printf("%d\n", sizeof(&a + 1)); // 取地址a取到整个数组的地址，+1跳过整个数组，就是下个数组的首元素地址
	//printf("%d\n", sizeof(&a[0]));//4
	//printf("%d\n", sizeof(&a[0] + 1));//4



	//char arr[] = { 'a', 'b', 'c', 'd', 'e', 'f' };
	////printf("%d\n", sizeof(arr)); //6
	////printf("%d\n", sizeof(arr + 0));//arr不是单独放在sizeof，arr就代表数组首元素地址，注意：地址是4/8个大小
	////printf("%d\n", sizeof(*arr));//首元素地址解引用，1
	////printf("%d\n", sizeof(arr[1]));//arr第二个元素的内容，1
	////printf("%d\n", sizeof(&arr));//4/8
	////printf("%d\n", sizeof(&arr + 1));//4/8
	////printf("%d\n", sizeof(&arr[0] + 1));//4/8

	//printf("%d\n", strlen(arr)); // 随机值
	//printf("%d\n", strlen(arr + 0)); // 随机值
	//printf("%d\n", strlen(*arr));// err，注意strlen设计的时候接收一个cha* 指针。这里arr首元素解引用，得到a的 。不行
	//printf("%d\n", strlen(arr[1]));//err，跟上面一个到底，arr[1]得到b
	//printf("%d\n", strlen(&arr));//随机值
	//printf("%d\n", strlen(&arr + 1)); //跳过一个数组，随机值-6
	//printf("%d\n", strlen(&arr[0] + 1));//先arr第0个元素+1，就是arr[1],取arr[1]的地址。就是随机值-1



	//char arr[] = "abcdef";

	//printf("%d\n", sizeof(arr)); //  7
	//printf("%d\n", sizeof(arr + 0));// 4/8
	//printf("%d\n", sizeof(*arr));//1
	//printf("%d\n", sizeof(arr[1]));//1
	//printf("%d\n", sizeof(&arr)); //4/8
	//printf("%d\n", sizeof(&arr + 1));//4/8
	//printf("%d\n", sizeof(&arr[0] + 1));//4/8

	//printf("%d\n", strlen(arr));// 6
	//printf("%d\n", strlen(arr + 0));//6
	////printf("%d\n", strlen(*arr));//err
	////printf("%d\n", strlen(arr[1]));//err
	//printf("%d\n", strlen(&arr));//6
	//printf("%d\n", strlen(&arr + 1));//随机值
	//printf("%d\n", strlen(&arr[0] + 1));//5


	char *p = "abcdef";
	//printf("%d\n", sizeof(p)); //4/8
	//printf("%d\n", sizeof(p + 1)); //4/8
	//printf("%d\n", sizeof(*p));//1
	//printf("%d\n", sizeof(p[0]));// p[0] == *(p+0)
	//printf("%d\n", sizeof(&p));// 4/8
	//printf("%d\n", sizeof(&p + 1));// 4/8
	//printf("%d\n", sizeof(&p[0] + 1)); // 4/8

	printf("%d\n", strlen(p)); // 6
	printf("%d\n", strlen(p + 1)); // 5
	//printf("%d\n", strlen(*p));//err ,strlen要传入地址
	//printf("%d\n", strlen(p[0]));//err,跟上面一样
	//printf("%d\n", strlen(&p));// 随机值
	printf("%d\n", strlen(&p + 1));// 随机值
	printf("%d\n", strlen(&p[0] + 1)); // 5
	
	return 0;
}
~~~

#### 练习：杨氏矩阵查找目标数

~~~c
#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>

//int find_num1(int arr[3][3],int r,int c,int k)
//{
//	int x = 0;
//	int y = c - 1;
//	
//	while (x <= r && y>=0)
//	{
//		if (arr[x][y] < k)
//		{
//			x++;
//		}
//		else if (arr[x][y] > k)
//		{
//			y--;
//		}
//		else
//		{
//			//printf("%d %d\n",x,y); // 函数目标要清晰，不掺杂别的东西
//			return 1;
//		}
//	}
//	return 0;
//}


//int find_num2(int arr[3][3], int * px, int * py,int k)
//{
//	int x = 0;
//	int y = *py - 1;
//
//	while (x <= *py  && y >= 0)
//	{
//		if (arr[x][y] < k)
//		{
//			x++;
//		}
//		else if (arr[x][y] > k)
//		{
//			y--;
//		}
//		else
//		{
//			*px = x;
//			*py = y;
//			return 1;
//		}
//	}
//
//	return 0;
//}
int main() 
{
//	//杨氏矩阵  判断一个数是否在矩阵 中
//	//一个由上到下，由左到右依次递增的矩阵
//	//1 2 3
//	//4 5 7
//	//7 8 9  
	int arr[3][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
	int k = 4;
	int x = 3;
	int y = 3;
	//设计一个函数，如果找到了就返回1，没找到返回0
	
	int ret1 = find_num1(arr,3,3,k);
	if (ret == 1)
{
		printf("找到了\n");
}
	else 
{
	printf("没找到\n");
}
	int ret2 = find_num2(arr,&x,&y,k);
	if (ret2 == 1)
{
		printf("找到了 下标：%d %d\n",x,y);
}
	else 
{
	printf("没找到\n");
}
return 0;
}
~~~

#### 练习：左旋转字符

~~~c
//void string_rotate(char * str,int k)
//{
//
//	int i = 0;
//	int len = strlen(str);
//	for (i = 0; i < k; i++)
//	{
//		char tmp = *str;
//		int j = 0;
//		for (j = 0; j < len - 1; j++)
//		{
//			str[j] = str[j + 1];
//		}
//		str[len - 1] = tmp;
//	}
//}
//int main()
//{
//	//字符串坐旋转，
//	//比如 ABCDEF 左旋两个字符 CDEFAB
//	char str[] = { "ABCDEF" };
//	int k = 5;
//	string_rotate(str,k);
//	printf("%s", str);
//	return 0;
//}





//还有一种方法
//比如ABCDEF 要左旋2个字符
//1.翻转AB BA
//2.再翻转 CDEF  FEDC   BAFEDC
//3.最后在整体翻转 CDEFAB

void reverse(char* left,char * right)
{
	while (left<=right)
{
		char tmp = *left;
		*left = *right;
		*right = tmp;
		left++;
		right--;
}
}
void rotate_reverse(char * str,int k)
{
	assert(str);
	int len = strlen(str);
	reverse(str, str + (k - 1)); //1
	reverse(str + k, str + (len - 1)); // 2
	reverse(str, str + (len - 1)); // 3
}
int main()
{
	char str[] = "ABCDEF";
	int k = 3;
	rotate_reverse(str,k);
	printf("%s", str);
	return 0;
}
~~~

#### 练习：写一个函数判断一个字符串是否为另一个字符串旋转之后的字符串

~~~c
//例如给定s1 = AABCD和BCDAA，返回1
//给定s1=abcd和s2=ACBD，返回2
int is_string_rotate(char* str1,int k,char * str2)
{

	int len = strlen(str1);
	
	int j = 0;
	for (j = 0; j < k; j++)
	{
		char tmp = *str1;
		int i = 0;
		for (i = 0; i < len - 1; i++)
		{
			*(str1 + i) = *(str1 + i + 1);
		}
		*(str1 + len - 1) = tmp;

		if (strcmp(str1, str2) == 0)
		{
			return 1;
		}
	}
	return 0;
}
int main()
{
	char str1[] = { "AABCD" };
	int k = 3;
	char str2[] = {"CDAAB"};
	int ret = is_string_rotate(str1, k, str2);
	if (ret == 1)
	{
		printf("是的\n");
	}
	else 
	{
		printf("不是\n");
		
	}
	return 0;
}

int is_string_rotate(char* str1, char* str2)
{
	int len = strlen(str1);
	//	strcat() 它不可以自己给自己追加字符串 
	strncat(str1, str1, len);
	char* ret = strstr(str1, str2);
	return ret != NULL;// 如果不等于NULL表示真返回1，否则返回0 
	//	如果不是一个空指针，说明是一个地址，找到了。 
	//	if(ret!= NULL)
	//	{	
	//		return 1; 
	//	} else 
	//	{
	//		return 0;
	//	}
}


//另外一种办法：
//int main()
//{
//	//	判断一个字符是否是另一个字符的左旋下下下雨 
//	//ABCDEFABCDEF 
//	//BCDEFABCDEFA
//	//CDEFABCDEFAB
//	//DEFABCDEFABC
//	//EFABCDEFABCD
//	//BCDEFABCDEFA
//	//ABCDEFABCDEF
//	char str1[20] = { "ABCDEFABCDEF" };
//	//    char str2[] = {"ABCDEFABCDEF"};
//	char str2[] = { "1" };
//	int ret = is_string_rotate(str1, str2);
//	if (ret == 1)
//	{
//		printf("是\n");
//	}
//	else {
//		printf("不是\n");
//	}
//	return 0;
//}
~~~



### 字符串函数和字符函数使用及实现

#### strlen

`size_t strlen(const char* string);`

- 字符串已经 '\0' 作为结束标志，strlen函数返回的是在字符串中 '\0' 前面出现的字符个数（不包
  含 '\0' )。
- 参数指向的字符串必须要以 '\0' 结束
- 注意函数的返回值为size_t，是无符号的（ 易错 ）
- 模拟实现strlen函数

#### strcpy

`char*strcpy(char* strDestination,const char* strSource);`

- 将第二个参数字符串内容拷贝到第一个参数字符串里面
- 源字符串必须以 '\0' 结束
- 会将源字符串中的 '\0' 拷贝到目标空间
- 目标空间必须足够大，以确保能存放源字符串
- 目标空间必须可变
- 学会模拟实现

##### 模拟实现strcpy

~~~c

~~~






